#!/usr/bin/env ruby
# vim: ft=ruby

require File.join(__dir__, '..', 'ruby', 'lib', 'images_helper')

# Group the images that start with the same things
# Determine if the set was {cropped, cropped+scaled, scaled, nothing}
# Move resulting images from set to done or source
# Rename them at the same time such that the source and non-source suffix number


module SortImagesAfterProcessing

  class Image < Dry::Struct::Value

    attribute :full_file_path, ImagesHelper::ImageStructTypes::Strict::String
    attribute :full_image_file_name, ImagesHelper::ImageStructTypes::Strict::String

  end

  class CroppedImages < Dry::Struct::Value

    attribute :source_image, Image
    attribute :cropped_image, Image

  end

  class ScaledImages < Dry::Struct::Value

    attribute :source_image, Image
    attribute :scaled_image, Image

  end

  class CroppedAndScaledImages < Dry::Struct::Value

    attribute :source_image, Image
    attribute :scaled_image, Image
    attribute :cropped_image, Image

  end

  include ImagesHelper::Constants

  def self.perform(args:)
    if args.include?('--help')
      command_name = File.basename(__FILE__)
      puts <<~HELPDOC
        USAGE:
            #{command_name}
                Sorts and renames images that were cropped by Croppola
            #{command_name} --test
                Reports which images will move but doesn't move them
            #{command_name} --help
                Prints this message
      HELPDOC
      exit 0
    end

    @test_run = args.include?('--test')

    image_paths = ImagesHelper.all_images_in_dir('.')

    images = hydrate_image_structs(image_paths: image_paths)

    sorted_images = sort_images_into_groups(images:)

    move_and_rename(image_groups: sorted_images)
  end

  def self.hydrate_image_structs(image_paths:)
    image_paths.map do |img|
      # TODO
      image_file_name = File.basename(img)
      # image_match = image_file_name.match(IMAGE_MATCHER)
      # raise "Unexpected match failure for #{image_file_name}" if image_match.blank?

      Image.new(
        full_file_path: img,
        full_image_file_name: image_file_name)
    end
  end
  private_class_method :hydrate_image_structs

  def self.sort_images_into_groups(images:)


    {
      cropped_and_scaled_images: [],
      cropped_images: [],
      scaled_images: [],
      unprocessed_images: []
    }
  end
  private_class_method :sort_images_into_groups

  def self.copy_and_rename(image_groups:)
    cropped_and_scaled_images = image_groups.fetch(:cropped_and_scaled_images)
    cropped_images = image_groups.fetch(:cropped_images)
    scaled_images = image_groups.fetch(:scaled_images)
    unprocessed_images = image_groups.fetch(:unprocessed_images)

    # TODO: Fix this section
    image_groups.each do |dir, images|
      puts ">>>>>>>>>>"
      puts "Creating directory '#{dir}'"
      FileUtils.mkdir_p(dir) if !@test_run
      puts "Moving #{images.length} to that directory"
      if !@test_run
        images.each do |img|
          new_path = File.join(dir, img.new_image_file_name)
          original_path = File.join(Dir.pwd, img.full_file_path)
          FileUtils.cp(original_path, new_path)
        end
      else
        images.each do |img|
          new_path = File.join(dir, img.new_image_file_name)
          original_path = File.join(Dir.pwd, img.full_file_path)
          puts "Moving from '#{original_path}' to '#{new_path}'"
        end
      end
      puts "<<<<<<<<<<"
    end
  end
  private_class_method :copy_and_rename

end

SortImagesAfterProcessing.perform(args: ARGV)
